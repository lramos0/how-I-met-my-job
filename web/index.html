<head>
    <title>üìÑ Resume Parser Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-light">
    <div class="container py-5">
        <h2 class="text-center fw-bold mb-4">üìÑ Resume Parser Dashboard</h2>

        <!-- Upload Section -->
        <div class="card p-4 shadow-sm mb-4">
            <h5 class="fw-bold mb-3">Upload Your Resume</h5>
            <input type="file" id="resumeFile" class="form-control mb-3" accept=".pdf,.docx,.txt">
            <button class="btn btn-primary" onclick="parseResume()">üöÄ Parse Resume</button>
            <p id="statusMsg" class="mt-3 text-muted"></p>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="card p-4 shadow-sm d-none">
            <h5 class="fw-bold mb-3">üßæ Resume Preview</h5>

            <div id="backendOutput" class="mb-4 p-3 border rounded bg-white"></div>
            <div id="parsedOutput" class="bg-light p-3 border rounded small"></div>

            <div class="text-end mt-4">
                <button class="btn btn-success me-2" onclick="downloadJSON()">üíæ Download JSON</button>
                <button class="btn btn-primary" onclick="goToJobsPage()">‚û°Ô∏è Continue to Job Matching</button>
            </div>
        </div>
    </div>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <script>
        /* --------------------------------------------------------
           PDF TEXT EXTRACTION
        --------------------------------------------------------- */
        async function extractPdfText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let finalText = "";

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();

                let pageText = "";
                let lastY = null;

                for (const item of textContent.items) {
                    const text = item.str;

                    // detect line breaks using vertical movement
                    if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                        pageText += "\n";
                    }

                    pageText += text;
                    lastY = item.transform[5];
                }

                finalText += pageText + "\n\n";
            }

            // Clean up weird double-spacing PDF.js often leaves
            finalText = finalText
                .replace(/\s{2,}/g, " ")
                .replace(/\n{3,}/g, "\n\n")
                .trim();

            return finalText;
        }


        /* --------------------------------------------------------
           FIX SMASHED WORDS
        --------------------------------------------------------- */
        function restoreWordBoundaries(text) {
            return text
                .replace(/([a-z])([A-Z])/g, "$1 $2")
                .replace(/([A-Z])([A-Z][a-z])/g, "$1 $2")
                .replace(/(\D)(\d)/g, "$1 $2")
                .replace(/(\d)(\D)/g, "$1 $2")
                .replace(/\s{2,}/g, " ")
                .trim();
        }

        /* --------------------------------------------------------
           SEND JSON ‚Üí BACKEND
        --------------------------------------------------------- */
        async function sendJSON(bodyObj) {
            try {
                const response = await fetch("/.netlify/functions/classify-cv", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(bodyObj)
                });

                const text = await response.text();
                try {
                    return JSON.parse(text);
                } catch {
                    console.error("Backend returned non-JSON:", text);
                    return null;
                }
            } catch (e) {
                console.error("Backend error:", e);
                return null;
            }
        }

        let resumeJSON = null;

        /* --------------------------------------------------------
           MAIN PARSER
        --------------------------------------------------------- */
        async function parseResume() {
            const fileInput = document.getElementById("resumeFile");
            const status = document.getElementById("statusMsg");

            if (!fileInput.files.length) {
                alert("Please upload a resume file first.");
                return;
            }

            const file = fileInput.files[0];
            status.textContent = `üìÑ Extracting text from ${file.name}‚Ä¶`;

            let resumeText = file.name.endsWith(".pdf")
                ? await extractPdfText(file)
                : await file.text();

            resumeText = restoreWordBoundaries(resumeText);
            console.log("Restored Resume Text:", resumeText);

            status.textContent = "ü§ñ Parsing resume‚Ä¶";

            resumeJSON = {
                inputs: [{
                    candidate_id: "CAND-" + Date.now(),
                    full_name: extractName(resumeText),
                    location: extractLocation(resumeText),
                    education_level: extractEducation(resumeText),
                    years_experience: estimateYears(resumeText),
                    skills: extractSkills(resumeText),
                    certifications: extractCerts(resumeText),
                    current_title: extractTitle(resumeText),
                    industries: extractIndustries(resumeText),
                    achievements: extractAchievements(resumeText)
                }],
                password: "craig123"
            };

            status.textContent = "üì° Sending to backend‚Ä¶";

            const response = await sendJSON(resumeJSON);
            console.log("Backend response:", response);

            if (response && Array.isArray(response.predictions) && response.predictions.length > 0) {
                const prediction = response.predictions[0];
                resumeJSON.inputs[0].competitive_score = prediction.competitive_score;
            }

            // Now show the preview *after* you've set the score
            document.getElementById("previewSection").classList.remove("d-none");
            displayParsedResume();

            status.textContent = "‚úÖ Resume parsed!";
        }

        /* --------------------------------------------------------
           DISPLAY PARSED RESUME
        --------------------------------------------------------- */
        function displayParsedResume() {
            const rec = resumeJSON.inputs[0];

            document.getElementById("parsedOutput").innerHTML = `
            <b>Name:</b> ${rec.full_name}<br>
            <b>Location:</b> ${rec.location}<br>
            <b>Education:</b> ${rec.education_level}<br>
            <b>Years Experience:</b> ${rec.years_experience}<br>
            <b>Title:</b> ${rec.current_title}<br>
            <b>Skills:</b> ${rec.skills.join(", ") || "None detected"}<br>
            <b>Certifications:</b> ${rec.certifications.join(", ") || "None"}<br>
            <b>Industries:</b> ${rec.industries.join(", ") || "Unknown"}<br>
            <b>Achievements:</b> ${rec.achievements.join(", ") || "None"}<br>
            <b>Competitive Score:</b> ${rec.competitive_score !== undefined ? rec.competitive_score : "N/A"}
        `;
        }

        /* --------------------------------------------------------
           FIELD EXTRACTORS
        --------------------------------------------------------- */
        function extractName(text) {
            // Stronger: looks for "Firstname Lastname" OR "First M. Last"
            const match = text.match(/\b([A-Z][a-z]+)\s+(?:[A-Z]\.{1}\s+)?([A-Z][a-z]+)\b/);
            return match ? `${match[1]} ${match[2]}` : "Unknown";
        }

        function extractLocation(text) {
            const match = text.match(/[A-Z][a-z]+,\s?[A-Z]{2}\b/);
            return match ? match[0] : "Unknown";
        }

        function extractEducation(text) {
            if (/master|m\.?s\.?\b/i.test(text)) return "Master";
            if (/bachelor|b\.?s\.?\b/i.test(text)) return "Bachelor";
            if (/ph\.?d|doctor/i.test(text)) return "PhD";
            return "Unknown";
        }

        function extractSkills(text) {
            // Expanded skill dictionary (canonical -> aliases)
            const skill_dict = {
                "python": ["python", "python3", "cpython", "pypy"],
                "java": ["java", "openjdk", "jdk", "jvm"],
                "javascript": ["javascript", "js", "nodejs", "ecmascript"],
                "typescript": ["typescript", "ts"],
                "go": ["go", "golang"],
                "c": ["c"],
                "c++": ["c++", "cpp"],
                "c#": ["c#", "csharp"],
                "ruby": ["ruby", "ruby on rails", "rails"],
                "php": ["php", "laravel", "symfony"],
                "rust": ["rust"],
                "kotlin": ["kotlin"],
                "scala": ["scala"],
                "r": ["r", "r language"],
                "swift": ["swift"],
                "shell": ["shell", "bash", "zsh", "sh"],
                "perl": ["perl"],
                "sql": ["sql", "mysql", "postgresql", "oracle", "sqlite", "mssql"],
                "nosql": ["nosql", "mongodb", "cassandra", "redis", "dynamodb", "couchdb"],
                "big data": ["big data", "hadoop", "spark", "mapreduce", "hive", "pig"],
                "data engineering": ["data engineering", "etl", "data pipeline", "airflow"],
                "data science": ["data science", "machine learning", "ml", "statistics"],
                "deep learning": ["deep learning", "neural networks", "tensorflow", "pytorch", "keras"],
                "mlops": ["mlops", "model deployment", "model serving", "sagemaker", "mlflow"],
                "nlp": ["nlp", "natural language processing", "transformers", "spacy", "nltk"],
                "computer vision": ["computer vision", "cv", "opencv"],
                "analytics": ["analytics", "business intelligence", "bi", "tableau", "power bi"],
                "rest": ["rest", "restful api", "api", "web api"],
                "graphql": ["graphql"],
                "web frameworks": ["django", "flask", "express", "spring", "rails", "fastapi"],
                "frontend frameworks": ["react", "angular", "vue", "svelte", "ember"],
                "html": ["html", "html5"],
                "css": ["css", "css3", "scss", "sass", "less"],
                "webpack": ["webpack", "rollup", "parcel"],
                "microservices": ["microservices", "service oriented architecture", "soa"],
                "devops": ["devops", "ci/cd", "continuous integration", "continuous delivery", "continuous deployment"],
                "docker": ["docker", "containers"],
                "kubernetes": ["kubernetes", "k8s", "kube"],
                "terraform": ["terraform"],
                "ansible": ["ansible"],
                "chef": ["chef"],
                "puppet": ["puppet"],
                "helm": ["helm"],
                "istio": ["istio", "service mesh"],
                "prometheus": ["prometheus", "grafana", "monitoring"],
                "logging": ["elk", "elasticsearch", "logstash", "kibana", "splunk"],
                "cloud aws": ["aws", "amazon web services", "ec2", "s3", "lambda", "cloudformation", "iam", "dynamodb"],
                "cloud azure": ["azure", "microsoft azure", "azure functions", "azure devops", "arm templates"],
                "cloud gcp": ["gcp", "google cloud", "google cloud platform", "gce", "bigquery", "cloud functions"],
                "openstack": ["openstack"],
                "serverless": ["serverless", "faas"],
                "edge computing": ["edge computing"],
                "networking": ["networking", "dns", "http", "tcp/ip"],
                "security": ["security", "kubernetes security", "oauth2", "jwt", "tls", "ssl", "vault"],
                "git": ["git", "gitlab", "github", "bitbucket"],
                "ci tools": ["jenkins", "circleci", "travis ci", "github actions", "gitlab ci", "azure pipelines"],
                "jira": ["jira", "confluence"],
                "slack": ["slack"],
                "docker-compose": ["docker-compose", "compose"],
                "testing": ["testing", "unit test", "integration test", "pytest", "junit", "mocha", "jest"],
                "performance": ["performance", "profiling", "benchmark"],
                "cache": ["cache", "redis", "memcached"],
                "microservices architecture": ["microservices architecture", "soa", "service mesh"],
                "design patterns": ["design patterns", "solid", "ddd", "clean architecture"],
                "architecture": ["architecture", "system design", "scalability", "high availability"],
                "agile": ["agile", "scrum", "kanban"],
                "devsecops": ["devsecops", "security as code", "shift left"],
                "observability": ["observability", "opentelemetry", "logging", "tracing", "metrics"]
            };

            const lower = text.toLowerCase();
            const found = [];

            // Iterate canonical skills and check aliases (short-circuit on first alias match)
            for (const canonical in skill_dict) {
                const aliases = skill_dict[canonical];
                for (let i = 0; i < aliases.length; i++) {
                    const a = aliases[i];
                    if (!a) continue;
                    if (lower.indexOf(a) !== -1) {
                        found.push(canonical);
                        break;
                    }
                }
            }

            // Remove duplicates and return
            return Array.from(new Set(found));
        }

        function extractCerts(text) {
            const certs = [];
            if (/aws solutions architect/i.test(text)) certs.push("AWS Solutions Architect");
            if (/pmp/i.test(text)) certs.push("PMP");
            return certs;
        }

        function extractTitle(text) {
            const roles = [
                "Software Engineer", "ML Engineer", "Data Scientist", "Developer",
                "Teacher", "Counselor", "Supervisor", "Specialist", "Consultant", "Manager", "Data Analyst", "Business Analyst"
            ];
            for (let r of roles) {
                const regex = new RegExp(r, "i");
                if (regex.test(text)) return r;
            }
            return "Unknown";
        }

        function estimateYears(text) {
            // Robust years-of-experience extraction
            // Handles patterns like:
            //  - "3-5 years" or "3 ‚Äì 5 years"
            //  - "5 years and 6 months"
            //  - "5+ years"
            //  - "since 2015" or "2015-2019"
            // Strategy: collect candidate numeric estimates and return the maximum (most likely total experience)
            const lower = text.toLowerCase();
            const now = new Date();
            const currentYear = now.getFullYear();

            const candidates = [];

            // 1) Ranges like "3-5 years" -> use the upper bound
            const rangeRe = /([0-9]+(?:\.[0-9]+)?)\s*[‚Äì-]\s*([0-9]+(?:\.[0-9]+)?)\s*(?:years?|yrs?)\b/gi;
            let m;
            while ((m = rangeRe.exec(lower)) !== null) {
                const hi = parseFloat(m[2]);
                if (!isNaN(hi)) candidates.push(hi);
            }

            // 2) "X years and Y months" or "X years, Y months"
            const yrsMonthsRe = /([0-9]+(?:\.[0-9]+)?)\s*(?:years?|yrs?)\s*(?:and|,)?\s*([0-9]+)\s*(?:months?|mos?)\b/gi;
            while ((m = yrsMonthsRe.exec(lower)) !== null) {
                const yrs = parseFloat(m[1]);
                const mos = parseInt(m[2]);
                if (!isNaN(yrs) && !isNaN(mos)) candidates.push(yrs + mos / 12);
            }

            // 3) Simple years: "5 years" or "5+ years" or "5 yrs"
            const yearsRe = /([0-9]+(?:\.[0-9]+)?)\s*\+?\s*(?:years?|yrs?)\b/gi;
            while ((m = yearsRe.exec(lower)) !== null) {
                const yrs = parseFloat(m[1]);
                if (!isNaN(yrs)) candidates.push(yrs);
            }

            // 4) Months-only mentions (convert to years)
            const monthsRe = /([0-9]+)\s*(?:months?|mos?)\b/gi;
            while ((m = monthsRe.exec(lower)) !== null) {
                const mos = parseInt(m[1]);
                if (!isNaN(mos)) candidates.push(mos / 12);
            }

            // 5) "since 2015" -> assume continuous employment until now
            const sinceRe = /since\s+(?:[a-z]{3,10}\s+)?(19|20)\d{2}\b/gi;
            while ((m = sinceRe.exec(lower)) !== null) {
                const year = parseInt(m[1] + m[0].slice(m[1].length + 6, m[0].length).match(/\d{2}/));
                // The above is a fallback; we'll instead extract the 4-digit year more simply
            }

            // Better handling for 'since' and explicit year ranges like 2015-2019
            const sinceYearRe = /since\s+(?:[a-z]{3,10}\s+)?(19|20)\d{2}\b/gi;
            while ((m = sinceYearRe.exec(lower)) !== null) {
                const yearMatch = m[0].match(/(19|20)\d{2}/);
                if (yearMatch) {
                    const y = parseInt(yearMatch[0]);
                    if (!isNaN(y) && y <= currentYear) candidates.push(currentYear - y);
                }
            }

            const yearRangeRe = /(19|20)\d{2}\s*[‚Äì-]\s*(?:present|now|(19|20)\d{2})/gi;
            while ((m = yearRangeRe.exec(lower)) !== null) {
                const parts = m[0].split(/[-‚Äì]/).map(p => p.trim());
                const startMatch = parts[0].match(/(19|20)\d{2}/);
                const endMatch = parts[1].match(/(19|20)\d{2}/);
                if (startMatch) {
                    const start = parseInt(startMatch[0]);
                    let end = currentYear;
                    if (endMatch) end = parseInt(endMatch[0]);
                    if (!isNaN(start) && !isNaN(end) && end >= start) candidates.push(end - start);
                }
            }

            // If we found any candidates return the maximum (likely total experience), rounded to one decimal
            if (candidates.length) {
                const max = Math.max(...candidates);
                return Math.round(max * 10) / 10;
            }

            // Fallback: pick the largest bare number followed by 'years' or 'yrs' as before
            const fallback = [...text.matchAll(/(\d+)\s+years?/gi)].map(m => parseInt(m[1]));
            if (fallback.length) return Math.max(...fallback);

            return 0;
        }

        function extractIndustries(text) {
            const industries = [];
            if (/education|teacher|child|school/i.test(text)) industries.push("Education");
            if (/software|developer/i.test(text)) industries.push("Software");
            if (/health|care/i.test(text)) industries.push("Healthcare");
            return industries;
        }

        function extractAchievements(text) {
            const achievements = [];
            if (/dean('|‚Äô)s list/i.test(text)) achievements.push("Dean's List");
            if (/chancellor('|‚Äô)s list/i.test(text)) achievements.push("Chancellor's List");
            return achievements;
        }

        /* --------------------------------------------------------
           DOWNLOAD + NAVIGATION
        --------------------------------------------------------- */
        function downloadJSON() {
            const blob = new Blob([JSON.stringify(resumeJSON, null, 2)], {
                type: "application/json"
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "parsed_resume.json";
            a.click();
        }

        function goToJobsPage() {
            localStorage.setItem("parsedResume", JSON.stringify(resumeJSON));
            window.location.href = "jobs.html";
        }
    </script>
</body>


</html>